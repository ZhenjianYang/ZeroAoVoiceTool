外挂语音的实现所需的步骤
------------------------

1.  找到游戏中显示对话或字幕的**时机**
2.  播放**对应**的语音

为了2的实现，我们在步骤1中要明白这句对话或字幕是什么（需要一个**标识**）

步骤1的实现
-----------

从原始的scena文件，到在屏幕上显示一句文本，大体经历了3个过程：

1.  加载整个scena文件到内存的地址A （此过程命名为： LoadScena）
2.  从A+offset1处读取一段话（可能包含多句，将一次性一起显示在屏幕上的称为一句）到地址B
    （此过程命名为： LoadBlock）
3.  从地址B开始，逐字显示文本。当显示完一句时，等待用户输入后再继续。此过程命名为（ShowText）

如果我们能够获取A与A+offset1，B，以及已加载在地址B的那段话中，正在显示的那句话的起始地址C相对B的偏移offset2。
那么，容易看出 offset = offset1 + offset2,
恰为这句话相对scena文件起始的偏移。用这个偏移以及其scena的名字（scena的开头内容即是其名字）共同作为前文提到的**标识**是再好不过了。

游戏会通过call指令调用上文提到的3个过程。那么，通过劫持这3个指令（通俗地说，就是修改游戏原本的call的目标地址为我们写入的代码的地址，等我们的代码运行结束后，再跳转至其本来应该跳转的地址。这样原本的游戏运行不会受影响，同时也能在我们需要的时机运行我们的代码），通过读取堆栈中参数来获取上述各个地址的值，具体来说：

-   通过LoadScena获取地址A

-   通过LoadBlock获取地址A+offset1

-   通过ShowText获取地址C（由于ShowText是逐字进行，我们必须在我们的代码中判断是否为句首。）

至于地址B，应当注意到第一次获得的C值即是B。为此，我们为每个调用均加上计数器，当通过ShowText的记数器从0变为1时，记录的C值记为B值。同时，我们也可以通过记数器的变化来确认各个步骤是否被调用——亦即步骤1中提及的**时机**。

这样我们实现了步骤1

步骤2的实现
-----------

我们必须将PC游戏中的文本与PS
Vita版的语音对应起来。这看似会个很繁琐的过程，但幸运的是，由于PC版游戏与PS
Vita版游戏十分**相似**，其对应的scena文件也十分**相似**，文本在scena文件中的分布也应该是**相似**的。那么，如果我们将PC版及PS
Vita版的scena中的文本均导出，那么文本的顺序是否也应该是**相似**的呢？如果答案为是的话，至少我们的工作量已经是大大减少了。

基于这个猜想的是ZaMakeVoiceTableFound与ZaMakeVoiceTablePrepare。

ZaMakeVoiceTablePrepare是基于某个规则来分别导出PC和PS
Vita版中的文本，我们希望尽可能导出所有的文本，并减少干扰文本（比如乱码）的数量

为了找到个合适的规则，制作了ZaMakeVoiceTableFound。ZaMakeVoiceTableFound的功能是导出PS
Vita版中所有包含语音的文本——这一点十分简单，因为PS
Vita版中所有包含语音的文本都含有类似“\#xxxxxxxV”的成分，其中xxxxxxx为语音编号，对应的语音文件为vxxxxxxx.wav——然后在导出的过程中，统计这些文本前后的字节组合。然后发现了个有趣的事实：对于零之轨迹，文本前的那个字节的组合仅有9种组合，而文本后的2个字节仅有5种组合。

ZaMakeVoiceTablePrepare中的这个规则，指的就是文本前的字节及文本后的两个字节的组合。

那么，利用这个规则可以保证所有的文本都导出了吗？

不能，但我们几乎可以保证的是，利用ZaMakeVoiceTableFound导出的文本——即含语音的文本——是用在这个规则下导出文本的子集。而其他的文本，我们并没有关系的必要。

我们寄希望于这种方法能够减少我们的工作量，而实际的结果，用这种方法（当然，需要根据导出结果微调导出规则）后，我们剩余的工作量已经是寥寥无几了：90%的文本已经是直接对应，而剩下的也无非是每个文件修改一两处的程度。

修改掉不对应的文本后，ZaMakeVoiceTable的工作就十分简单了：将对应的文本中，PC版的文本相对scena文件的偏移与PS
Vita版的语音编号，提取出来记录下来就可以了

这样步骤2也得以实现

完成程序
--------

当两个步骤都找到解决方案时，剩下的就是用代码来实现了。具体请参考项目里源码，这里就不加赘述了。

问题及解决法
------------

**最初的设想**

最初，并没有通过注入代码——而只是通过监视内存——来达到获取各个地址的目的。但由于本人逆向技术的局限性，能够找到的各个地址都只是位于栈上的，因其生命周期过短无法通过监视内存来获取。

那么现在重新提问：只是通过监视内存，有解决的方案吗？或者，其他更加稳定的方案？

**scena\_1**

部分scena文件带有后缀\_1与\_2。scena\_1与scena\_2并不会单独载入，而是作为scena的补充、与scena同时载入内存。我们通过LoadScena获取了scena载入的地址A，但无法获取scena\_1的载入地址A\_1。这样显示scena\_1中的文本时，由于无法计算出offset1，也就无法计算出offset，因而这些文本对应的语音将无法被播放。

**解决**：scena\_1与scena\_2的载入通过call
LoadScena1来实现（事实上LoadScena1与LoadScena调用的是同一地址，但调用位置不同，我们仍然认为这两个调用是不同的）。那么劫持LoadScena1，获取地址A\_1与A\_2。由于scena必然是先被载入，在scena载入时，清空A\_1与A\_2。这样，根据A\_1是否为零就可以判断此次判断载入的是scena\_1还是scena\_2。

而根据LoadBlock中获取的A+offset1，我们可以判断出当前的段落属于是属于scena\_1、scena\_2还是scena。因为这三者并不会重叠。

另外，值得一提的是，scena\_1与scena\_2的开头部分（scena保存名字的地方）存储的是scena或其他毫不相干的内容，其真正的名字需通过0x34处的int值指定的偏移处获得。并且，xyyyy\_1未必与xyyyy同时载入，也有可能是与wzzzz同时载入。

**PS Vita版的一句对应了PC版的两句**

由于PS
Vita版剧情脚本的轻微改动，一个版本有的台词在另一个版本总没有也并不奇怪。处理也异常简单：删掉多出的台词就行了。但一边的一句话对应了另一边的两句是可能的吗？答案是肯定的，比如PC版两句话因为太短，PS
Vita版合并为一句语音；或者，PC版两个角色同时说了一句话，PS
Vita也只需一句来处理。

**解决**：对于前者，将语音分派到第一句；对于后者，同时分配到两句，先播放的语音在刚播放的瞬间就会被后一句终止

**PC版的一句对应了PS Vita版的两句**

**解决**：由于无法为一句话分配两句语音，这个问题的解决要稍微麻烦一点。不过，观察到，这种情况的出现有个共同特点：文本中使用了等待指令（形式为\#xxxW），等待前与等待后语音在PSVita版中分成了两句。前文已经提及，ShowText是逐字进行的，我们在注入的代码中加入了句首的判断。那么，若我们在代码加入检查，若检测到\#xxxW指令，那么下一次调用ShowText时，我们无条件认为其是句首。这样，我们将PC版的一句话也断为了两句。

另外，配合此的修改是，语音播放时，允许等待上一条语音播放完之后再进行下一语音的播放，已应对等待时间过短的情况。此时应在文本偏移值上加上0x10000000以告知这条语音是需要等待上一条语音播放完后再进行播放。

**禁用原本的语音**

PC版的游戏本来就包含一些非战斗语音，如果不关闭非战斗语音，与本工具一起使用时，可能会出现游戏和本工具同时播放了语音的情况。但是，若只是简单地在游戏设置中关闭非战斗语音，一些非剧情语音如语气语音也会被关闭；而本工具能够提供的仅是剧情语音。这可能会影响体验。

对于碧之轨迹，本工具实验性地实现了禁用原本剧情语音的功能。由于PC版游戏的语音播放指令为\#xxxxV的形式，其中xxxx为语音编号，对应语音文件为ed7vxxxx.wav，故在ShowText中若检测到这样的指令，直接将xxxx更改为9999这个不存在的语音编号，即可实现原剧情语音的禁用。

然而，这仍不是一个完善的解决方案。

**自动播放的文本**

PC版游戏中，有部分文本是自动播放的。而且，由于PC版无语音的关系，这些自动播放的文本的等待时间很短。PS
Vita中加长了等待时间。PC版该如何解决呢？我们并不希望看到前一句语音还未播放完就被后一句打断的情况；但若只是单纯地等待前一句语音放完，又会出现语音和字幕不同步的情况。

答：尚未找到解决方法
